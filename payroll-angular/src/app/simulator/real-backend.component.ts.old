import { Component, signal, computed, effect, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { AuthService } from '../services/auth.service';
import { EmployeeService } from '../services/employee.service';
import { PayrollService } from '../services/payroll.service';
import { CompanyService } from '../services/company.service';
import { formatCurrency, calculateBasicSalary } from '../simulator/salary-calculator';
import type { Employee, PayrollCalculationResponse, UserProfile } from '../models/api.types';

@Component({
  selector: 'app-real-backend',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: '../simulator/simulator.component.html',
  styleUrls: ['../simulator/simulator.component.css']
})
export class RealBackendComponent implements OnInit {
  private authService = inject(AuthService);
  private employeeService = inject(EmployeeService);
  private payrollService = inject(PayrollService);
  private companyService = inject(CompanyService);

  // State signals
  isLoggedIn = signal(false);
  employees = signal<LocalEmployee[]>([]);
  companyAccountBalance = signal(0);
  companyId = signal('');
  grade6Basic = signal(25000);
  view = signal<'employees' | 'salarySheet' | 'addEdit' | 'home'>('employees');
  editEmployee = signal<LocalEmployee | null>(null);
  message = signal('');
  topUpAmount = signal(0);
  isTopUpModalOpen = signal(false);
  sortConfig = signal<{key: string, direction: 'asc' | 'desc'} | null>(null);
  loading = signal(false);
  
  // Payment status
  paymentStatus = signal({ totalPaid: 0, requiredTopUp: 0 });
  
  // Login credentials
  loginUsername = signal('');
  loginPassword = signal('');
  
  // Form data for employee edit
  formData = signal<LocalEmployee | null>(null);
  
  // Pagination state
  employeePage = signal(0);
  employeePageSize = signal(5);
  
  // User profile
  userProfile = signal<any>(null);
  
  // Constants
  GRADE_LEVELS = [6, 5, 4, 3, 2, 1];
  
  // Auto-dismiss toast
  constructor() {
    effect(() => {
      const msg = this.message();
      if (msg) {
        setTimeout(() => this.message.set(''), 5000);
      }
    });
  }

  ngOnInit() {
    // Check if already logged in
    if (this.authService.isAuthenticated()) {
      this.isLoggedIn.set(true);
      this.loadInitialData();
    }
  }
  
  // Computed values
  basicSalariesByGrade = computed(() => {
    const grade6 = this.grade6Basic();
    const result: Record<number, number> = {};
    this.GRADE_LEVELS.forEach(grade => {
      result[grade] = calculateBasicSalary(grade, grade6);
    });
    return result;
  });
  
  totalSalaryRequired = computed(() => {
    return this.employees().reduce((total, emp) => total + (emp.salary?.gross || 0), 0);
  });
  
  sortedEmployees = computed(() => {
    const emps = [...this.employees()];
    const config = this.sortConfig();
    
    if (!config) return emps;
    
    return emps.sort((a, b) => {
      const { key, direction } = config;
      let aValue: any;
      let bValue: any;
      
      switch(key) {
        case 'grade':
          aValue = a.grade;
          bValue = b.grade;
          break;
        case 'name':
          aValue = a.name;
          bValue = b.name;
          break;
        case 'id':
          aValue = a.code;
          bValue = b.code;
          break;
        case 'balance':
          aValue = a.bankAccount.balance;
          bValue = b.bankAccount.balance;
          break;
        default:
          aValue = a.name;
          bValue = b.name;
      }
      
      if (typeof aValue === 'number' && typeof bValue === 'number') {
        return direction === 'asc' ? aValue - bValue : bValue - aValue;
      }
      
      const aStr = String(aValue).toLowerCase();
      const bStr = String(bValue).toLowerCase();
      
      if (aStr < bStr) return direction === 'asc' ? -1 : 1;
      if (aStr > bStr) return direction === 'asc' ? 1 : -1;
      return 0;
    });
  });
  
  paginatedEmployees = computed(() => {
    const sorted = this.sortedEmployees();
    const page = this.employeePage();
    const size = this.employeePageSize();
    const startIndex = page * size;
    return sorted.slice(startIndex, startIndex + size);
  });
  
  totalEmployeePages = computed(() => {
    return Math.ceil(this.sortedEmployees().length / this.employeePageSize());
  });
  
  getNextEmployeeId(): string {
    const ids = this.employees().map(e => parseInt(e.code)).filter(id => !isNaN(id));
    return String(Math.max(1000, ...ids) + 1);
  }
  
  // API Methods
  loadInitialData(): void {
    this.loading.set(true);
    
    // Load employees
    this.employeeService.getAll().subscribe({
      next: (data) => {
        const localEmps: LocalEmployee[] = data.map(emp => ({
          id: emp.id,
          code: emp.code,
          name: emp.name,
          address: emp.address,
          mobile: emp.mobile,
          grade: emp.grade.rank,
          bankAccount: {
            name: emp.account.accountName,
            number: emp.account.accountNumber,
            balance: emp.account.currentBalance,
            type: emp.account.accountType,
            bank: emp.account.branchName,
            branch: emp.account.branchName
          },
          salary: emp.salary || undefined
        }));
        
        this.employees.set(localEmps);
        
        // Get company from first employee
        if (data.length > 0 && data[0].company) {
          this.companyId.set(data[0].company.id);
          this.loadCompanyData(data[0].company.id);
        }
        
        this.loading.set(false);
        this.message.set('‚úÖ Employees loaded successfully');
      },
      error: (error) => {
        console.error('Failed to load employees:', error);
        this.message.set('‚ùå Failed to load employees');
        this.loading.set(false);
      }
    });
  }
  
  loadCompanyData(id: string): void {
    this.companyService.getCompany(id).subscribe({
      next: (company) => {
        this.companyAccountBalance.set(company.mainAccount.currentBalance);
      },
      error: (error) => {
        console.error('Failed to load company:', error);
      }
    });
  }
  
  async handleLogin(event: Event): Promise<void> {
    event.preventDefault();
    this.loading.set(true);
    const credentials = {
      username: this.loginUsername(),
      password: this.loginPassword()
    };
    const success = await this.authService.login(credentials);
    if (success) {
      this.isLoggedIn.set(true);
      this.userProfile.set(this.authService.getCurrentUser());
      this.message.set('‚úÖ Login successful!');
      this.loadInitialData();
      this.view.set('home'); // Show dashboard/home
    } else {
      this.isLoggedIn.set(false);
      this.message.set('‚ùå Login failed. Please check credentials.');
    }
    this.loading.set(false);
  }
  
  handleLogout(): void {
    this.authService.logout();
    this.isLoggedIn.set(false);
    this.employees.set([]);
    this.companyAccountBalance.set(0);
    this.message.set('üëã Logged out successfully');
  }
  
  calculateSalaries(): void {
    this.loading.set(true);
    
    this.payrollService.calculateSalaries(this.grade6Basic()).subscribe({
      next: (response) => {
        // Update employees with calculated salaries
        const updatedEmps = this.employees().map(emp => {
          const salaryInfo = response.salaries.find(s => s.employeeId === emp.id);
          if (salaryInfo) {
            return {
              ...emp,
              salary: {
                basic: salaryInfo.basicSalary,
                houseRent: salaryInfo.houseRentAllowance,
                medicalAllowance: salaryInfo.medicalAllowance,
                gross: salaryInfo.grossSalary,
                isPaid: false
              }
            };
          }
          return emp;
        });
        
        this.employees.set(updatedEmps);
        this.loading.set(false);
        this.message.set(`‚úÖ Calculated salaries for ${response.employeeCount} employees. Total: ${formatCurrency(response.totalPay)}`);
      },
      error: (error) => {
        console.error('Failed to calculate salaries:', error);
        this.message.set('‚ùå Failed to calculate salaries');
        this.loading.set(false);
      }
    });
  }
  
  transferSalaries(): void {
    const totalRequired = this.totalSalaryRequired();
    const balance = this.companyAccountBalance();
    
    if (totalRequired === 0) {
      this.message.set('‚ö†Ô∏è Please calculate salaries first');
      return;
    }
    
    if (balance < totalRequired) {
      const shortfall = totalRequired - balance;
      this.paymentStatus.set({
        totalPaid: 0,
        requiredTopUp: shortfall
      });
      this.isTopUpModalOpen.set(true);
      this.message.set(`‚ùå Insufficient funds! Need ${formatCurrency(shortfall)} more`);
      return;
    }
    
    this.loading.set(true);
    
    const transferData = {
      companyId: this.companyId(),
      salaries: this.employees()
        .filter(emp => emp.salary && !emp.salary.isPaid)
        .map(emp => ({
          employeeId: emp.id,
          amount: emp.salary!.gross
        }))
    };
    
    this.payrollService.transferSalaries(transferData).subscribe({
      next: (response) => {
        // Mark all as paid
        const updatedEmps = this.employees().map(emp => {
          if (emp.salary) {
            return {
              ...emp,
              salary: { ...emp.salary, isPaid: true }
            };
          }
          return emp;
        });
        
        this.employees.set(updatedEmps);
        this.paymentStatus.set({
          totalPaid: response.totalAmount,
          requiredTopUp: 0
        });
        
        // Reload company balance
        this.loadCompanyData(this.companyId());
        
        this.loading.set(false);
        this.message.set(`‚úÖ Successfully transferred salaries to ${response.processedCount} employees!`);
      },
      error: (error) => {
        console.error('Failed to transfer salaries:', error);
        this.message.set('‚ùå Failed to transfer salaries');
        this.loading.set(false);
      }
    });
  }
  
  handleTopUp(): void {
    const amount = this.topUpAmount();
    if (amount <= 0) {
      this.message.set('‚ö†Ô∏è Please enter a valid amount');
      return;
    }
    
    this.loading.set(true);
    
    this.companyService.topUp({
      companyId: this.companyId(),
      amount: amount,
      description: 'Account top-up'
    }).subscribe({
      next: (response) => {
        this.companyAccountBalance.set(response.newBalance);
        this.topUpAmount.set(0);
        this.isTopUpModalOpen.set(false);
        this.loading.set(false);
        this.message.set(`‚úÖ Added ${formatCurrency(amount)}. New balance: ${formatCurrency(response.newBalance)}`);
      },
      error: (error) => {
        console.error('Failed to top up:', error);
        this.message.set('‚ùå Failed to add funds');
        this.loading.set(false);
      }
    });
  }
  
  // UI Methods (same as simulator)
  handleSort(key: string): void {
    const current = this.sortConfig();
    if (current?.key === key) {
      this.sortConfig.set({
        key,
        direction: current.direction === 'asc' ? 'desc' : 'asc'
      });
    } else {
      this.sortConfig.set({ key, direction: 'asc' });
    }
  }
  
  getSortIcon(key: string): string {
    const config = this.sortConfig();
    if (config?.key !== key) return '‚ÜïÔ∏è';
    return config.direction === 'asc' ? '‚Üë' : '‚Üì';
  }
  
  startAddEmployee(): void {
    const nextId = this.getNextEmployeeId();
    this.formData.set({
      id: '',
      code: nextId,
      name: '',
      address: '',
      mobile: '',
      grade: 6,
      bankAccount: {
        name: '',
        number: '',
        balance: 0,
        type: 'Savings',
        bank: '',
        branch: ''
      }
    });
    this.editEmployee.set(null);
    this.view.set('addEdit');
  }
  
  handleEditEmployee(emp: LocalEmployee): void {
    this.formData.set({ ...emp });
    this.editEmployee.set(emp);
    this.view.set('addEdit');
  }
  
  handleCancelEdit(): void {
    this.formData.set(null);
    this.editEmployee.set(null);
    this.view.set('employees');
  }
  
  handleSaveEmployee(): void {
    const data = this.formData();
    if (!data) return;
    
    // Validation would go here
    
    this.loading.set(true);
    
    if (this.editEmployee()) {
      // Update existing
      this.employeeService.update(data.id, data as any).subscribe({
        next: () => {
          this.loadInitialData();
          this.handleCancelEdit();
          this.message.set('‚úÖ Employee updated successfully');
        },
        error: (error) => {
          console.error('Failed to update employee:', error);
          this.message.set('‚ùå Failed to update employee');
          this.loading.set(false);
        }
      });
    } else {
      // Create new
      this.employeeService.create(data as any).subscribe({
        next: () => {
          this.loadInitialData();
          this.handleCancelEdit();
          this.message.set('‚úÖ Employee added successfully');
        },
        error: (error) => {
          console.error('Failed to add employee:', error);
          this.message.set('‚ùå Failed to add employee');
          this.loading.set(false);
        }
      });
    }
  }
  
  handleDeleteEmployee(id: string): void {
    if (!confirm('Are you sure you want to delete this employee?')) return;
    
    this.loading.set(true);
    
    this.employeeService.delete(id).subscribe({
      next: () => {
        this.loadInitialData();
        this.message.set('‚úÖ Employee deleted successfully');
      },
      error: (error) => {
        console.error('Failed to delete employee:', error);
        this.message.set('‚ùå Failed to delete employee');
        this.loading.set(false);
      }
    });
  }
  
  updateFormField(field: string, value: any): void {
    const current = this.formData();
    if (current) {
      this.formData.set({ ...current, [field]: value });
    }
  }
  
  updateBankField(field: string, value: any): void {
    const current = this.formData();
    if (current) {
      this.formData.set({
        ...current,
        bankAccount: { ...current.bankAccount, [field]: value }
      });
    }
  }
  
  setEmployeePage(page: number): void {
    const maxPage = this.totalEmployeePages() - 1;
    if (page >= 0 && page <= maxPage) {
      this.employeePage.set(page);
    }
  }
  
  setEmployeePageSize(size: number): void {
    this.employeePageSize.set(size);
    this.employeePage.set(0);
  }
  
  openTopUpModal(): void {
    this.paymentStatus.set({ totalPaid: 0, requiredTopUp: 0 });
    this.isTopUpModalOpen.set(true);
  }
  
  closeTopUpModal(): void {
    this.isTopUpModalOpen.set(false);
  }
  
  formatCurrency(amount: number): string {
    return formatCurrency(amount);
  }
}
